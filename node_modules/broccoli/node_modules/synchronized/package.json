{
  "name": "synchronized",
  "description": "Ensure that some code always executes exclusively, in the order it is called",
  "version": "0.1.7",
  "author": {
    "name": "Pieter Raubenheimer",
    "email": "pieter@wavana.com"
  },
  "keywords": [
    "mutex",
    "asynchronous",
    "synchronous",
    "queue"
  ],
  "main": "./synchronized-bind.js",
  "engines": {
    "node": ">= 0.6.0"
  },
  "dependencies": {},
  "devDependencies": {
    "async": "0.1.18",
    "nodeunit": "0.7.4"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:jupiter/node-synchronized.git"
  },
  "readme": "node-synchronized\n=================\n\nEnsure that some code always executes exclusively, in the order it is called\n\nUsage\n-----\n\n### synchronized(scopeObj, fn, done) ###\n\n- scopeObj - An object or string as scope\n- fn(cb) - The function to call one at a time per scope, first argument is the \ncallback to call on completion, e.g. `function(done) { process.nextTick(done) }`\n- done - (Optional) Called when execution of the provided function has \ncompleted, called with same arguments as provided callback\n\n### synchronized.fn(scopeObj, fn) ###\n\n- scopeObj - (Optional) An object or string as scope, default: `null` (global)\n- fn(..., cb) - cb as above.  Other arguments passed from newFn.\n\nReturns:\n- newFn(..., cb) - First arguments passed to fn, last argument \ncallback\n\nExamples\n--------\n\nThis is particularly useful if you have some asynchronous code that should not\nbe executing concurrently, such as a cached database call, where calling it \nmultiple times would result in the caching functionality not having an effect.\n\n```\n  var synchronized = require('synchronized');\n  \n  MyObject.prototype.fetchedDocument = function(id, cb) {\n    var self = this;\n    \n    synchronized(self._documentCache, function(done){\n      // Return cached response if available\n      if (self._documentCache[id]) { \n        return done(null, self._documentCache[id]);\n      }\n\n      // Otherwise fetch\n      Model.findById(id, function(err, document){\n        if (err) {\n          return done(err);\n        }\n        \n        self._documentCache[id] = document;\n        done(null, document);\n      });\n    }, cb);\n  }\n\n```\n\nIf you are using passing multiple asynchronous functions to a flow-control \nlibrary method, such as [async](https://github.com/caolan/async).parallel(), \nand you have a dependency or other reason for wanting a subset of the executed\nfunctions not be called concurrently.\n\n```\n\n  async.parallel({\n    company: synchronized.fn(this.companyId, function(done){\n      person.fetchedCompany(done);\n    }),\n    \n    // ... Other functions\n    \n    companyManager: synchronized.fn(this.companyId, function(done){\n      person.fetchedCompany(function(err, company){\n        if (err) etc.\n        \n        done(null, company.manager);\n      });\n    })\n  }, function(err, results){\n    if (err) etc.\n    \n    // ...\n  });\n  \n```\n\nInstallation\n------------\n\n\nInspiration\n-----------\n\nLicense\n-------",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jupiter/node-synchronized/issues"
  },
  "homepage": "https://github.com/jupiter/node-synchronized",
  "_id": "synchronized@0.1.7",
  "_from": "synchronized@~0.1.7"
}
